import { Connection, Keypair, PublicKey, SystemProgram } from '@solana/web3.js';
import * as anchor from '@project-serum/anchor';
import { AnchorProvider, Program, Wallet } from '@project-serum/anchor';
import fs from 'fs';
import os from 'os';
import 'dotenv/config';

import idl from '../solvend.json'; // <-- Correct way to import JSON
import { Solvend } from '../solvend';   // <-- This is the types file generated by Anchor

// --- Basic Setup ---
const connection = new Connection(process.env.SOLANA_RPC_HOST!, 'confirmed');
const programId = new PublicKey(process.env.PROGRAM_ID!);

function getBackendWallet(): Keypair {
  const walletPath = process.env.BACKEND_WALLET_PATH!.replace('~', os.homedir());
  if (!walletPath || !fs.existsSync(walletPath)) {
    throw new Error("Backend wallet not found at path");
  }
  const walletData = JSON.parse(fs.readFileSync(walletPath, 'utf-8'));
  return Keypair.fromSecretKey(new Uint8Array(walletData));
}

const backendWallet = getBackendWallet();
const provider = new AnchorProvider(connection, new Wallet(backendWallet), { commitment: 'confirmed' });
const program = new Program<Solvend>(idl as any, programId, provider);

// --- Service Functions ---

export async function createVoucherOnChain(user: PublicKey, otpHash: Buffer, nonce: number) {
  const [voucherPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("voucher"), user.toBuffer(), new anchor.BN(nonce).toArrayLike(Buffer, 'le', 8)],
    programId
  );

  console.log(`Creating voucher for user ${user.toBase58()} at PDA ${voucherPda.toBase58()}`);

  const expiryTimestamp = Math.floor(Date.now() / 1000) + 3600;

  try {
    const txSignature = await program.methods
      .createVoucher(otpHash as any, new anchor.BN(expiryTimestamp), false, new anchor.BN(nonce))
      .accounts({
        voucher: voucherPda,
        user: user,
        authority: backendWallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([backendWallet])
      .rpc();
    
    console.log("Create voucher transaction successful:", txSignature);
    return txSignature;
  } catch (error) {
    console.error("Failed to create voucher on-chain:", error);
    throw error;
  }
}

export async function redeemAndIncrement(user: PublicKey, nonce: number, optIn: boolean) {
  const [voucherPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("voucher"), user.toBuffer(), new anchor.BN(nonce).toArrayLike(Buffer, 'le', 8)],
    programId
  );
  
  const [userProgressPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("user"), user.toBuffer()],
    programId
  );
  
  const [machinePda] = PublicKey.findProgramAddressSync(
      [Buffer.from("machine")],
      programId
  );

  console.log(`Redeeming voucher for user ${user.toBase58()}`);

  try {
    const txSignature = await program.methods
      .redeemVoucher()
      .accounts({
        voucher: voucherPda,
        authority: backendWallet.publicKey,
      })
      .postInstructions([
        await program.methods
            .incrementProgress(optIn)
            .accounts({
                userProgress: userProgressPda,
                machineConfig: machinePda,
                user: user,
                authority: backendWallet.publicKey,
                systemProgram: SystemProgram.programId,
            })
            .instruction()
      ])
      .signers([backendWallet])
      .rpc();
      
    console.log("Redeem & Increment transaction successful:", txSignature);
    return txSignature;
  } catch (error) {
      console.error("Failed to redeem and increment:", error);
      throw error;
  }
}